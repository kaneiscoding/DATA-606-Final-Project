tracks_df[478628,]
tracks_clean <- tracks_df[-478628,]
plt2 <- ggplot(tracks_clean, aes(x = factor(decade), y = acousticness)) +
geom_bar(stat = "summary", fun = "mean")
plt3 <- ggplot(tracks_clean, aes(x = factor(decade), y = energy)) +
geom_bar(stat = "summary", fun = "mean")
plt1 <- ggplot(tracks_clean, aes(x = factor(decade), y = popularity)) +
geom_bar(stat = "summary", fun = "mean")
plt4 <- ggplot(tracks_clean, aes(x = factor(decade), y = duration_ms)) +
geom_bar(stat = "summary", fun = "mean")
grid.arrange(plt1, plt2, plt3, plt4, top = "Variation by Decade", ncol = 2)
# Calculate the correlation matrix
cor_matrix <- cor(popular_numeric)
# plot the correlation
ggcorrplot(cor_matrix,
hc.order = TRUE,
type = "lower",
lab = TRUE,
show.legend = FALSE
)
box1 <- ggplot(data = tracks_df, aes(x=factor(key), y=popularity, fill=factor(key))) + geom_boxplot()
box2 <- ggplot(data = tracks_df, aes(x=factor(explicit), y=popularity, fill=factor(explicit))) + geom_boxplot()
grid.arrange(box1, box2, ncol = 2, top="Boxplots of Factors vs. Popularity")
quant_pop <- tracks_df %>%
mutate(quartile = factor(ntile(popularity, 4)),
hit = case_when(quartile == 4 ~"hit", TRUE~"no_hit"))
box1 <- ggplot(data = quant_pop, aes(x=hit, y=loudness, fill=hit)) + geom_boxplot(outlizer.size=0.1)
box2 <- ggplot(data = quant_pop, aes(x=hit, y=danceability, fill=hit)) + geom_boxplot()
box3 <- ggplot(data = quant_pop, aes(x=hit, y=tempo, fill=hit)) + geom_boxplot()
box4 <- ggplot(data = quant_pop, aes(x=hit, y=valence, fill=hit)) + geom_boxplot()
box5 <- ggplot(data = quant_pop, aes(x=hit, y=energy, fill=hit)) + geom_boxplot()
box6 <- ggplot(data = quant_pop, aes(x=hit, y=instrumentalness, fill=hit)) + geom_boxplot()
grid.arrange(box1, box2, box3, box4, box5, box6, ncol = 3, top="Boxplots of Features vs. Hit")
grid.arrange(box5, box2, box3, ncol = 3, top="Boxplots of Features vs. Hit")
popular_df2 <- popular_df2 %>% mutate(popularity_coded = ifelse(popularity >= quantile(popular_df2$popularity, c(.75))[1], 1, 0))
# Convert the outcome variable to a factor
popular_df2$popularity_coded <- as.factor(popular_df2$popularity_coded)
# control object for k-fold cross validation
ctrl <- trainControl(method = "cv", number = 10)
#fit a regression model and use k-fold CV to evaluate performance
lda_model <- train(popularity_coded~duration_ms+explicit+ danceability+energy+key+loudness+mode+speechiness+acousticness+instrumentalness+liveness+valence+tempo+time_signature, data=popular_df2, method = "lda", trControl = ctrl)
print(lda_model)
# Multivariate Normality
N <- nrow(popular_scaled)
idx = sample(1:N, size=1000, replace = FALSE)
popular_sample = popular_scaled[idx,]
mult.norm(popular_sample)$mult.test
# Equality of Variance
popularity_var_test <- data.frame(popular_factors, popular_df2["popularity"])
N <- nrow(popularity_var_test)
idx = sample(1:N, size=1000, replace = FALSE)
popular_sample2 = popularity_var_test[idx,]
leveneTest(popularity~., data = popular_sample2)
#fit a regression model and use k-fold CV to evaluate performance
lr_model <- train(popularity_coded ~ duration_ms+explicit+danceability+energy+key+loudness+mode+speechiness+acousticness+instrumentalness+liveness+valence+tempo+time_signature, data = popular_df2, method = "glm", trControl = ctrl, family="binomial")
summary(lr_model)
## VIF
model_fit<-lm(popularity~duration_ms+factor(explicit)+ danceability+energy+factor(key)+loudness+factor(mode)+speechiness+acousticness+instrumentalness+liveness+valence+tempo+factor(time_signature), data=popular_df2)
vif(model_fit)
# Influential Outliers
popular_df[cooks.distance(model_fit)>1,]
tree_model_class <- train(popularity_coded ~ duration_ms+explicit+danceability+energy+key+loudness+mode+speechiness+acousticness+instrumentalness+liveness+valence+tempo+time_signature, data = popular_df2, trControl = ctrl, method = "rpart")
print(tree_model_class)
plot(tree_model_class)
text(tree_model_class, cex=0.5, col="blue")
plot(tree_model_class)
View(tree_model_class)
tree.class <- tree(popularity_coded ~ duration_ms+explicit+danceability+energy+key+loudness+mode+speechiness+acousticness+instrumentalness+liveness+valence+tempo+time_signature, data = popular_df2)
summary(tree.class)
plot(tree.class)
text(tree.class, cex=0.5, col="blue")
set.seed(1)
N <- nrow(popular_df2)
n <- N * 0.8
idx = sample(1:N, size=n, replace = FALSE)
train = popular_df2[idx,]
test = popular_df2[-idx,]
tree.class <- tree(popularity_coded ~ duration_ms+explicit+danceability+energy+key+loudness+mode+speechiness+acousticness+instrumentalness+liveness+valence+tempo+time_signature, data = train)
summary(tree.class)
plot(tree.class)
text(tree.class, cex=0.5, col="blue")
tree.pred <- predict(tree.class, test, type = "class")
tab <- table(tree.pred, test$Type)
tree.pred <- predict(tree.class, test, type = "class")
tab <- table(tree.pred, test$popularity_coded)
tab
mis = 1 - sum(diag(tab)) / sum(tab)
mis
tree.class <- tree(popularity_coded ~ duration_ms+explicit+danceability+energy+key+loudness+mode+speechiness+acousticness+instrumentalness+liveness+valence+tempo+time_signature, data = train)
summary(tree.class)
plot(tree.class)
text(tree.class, cex=0.5, col="purple")
tree.class <- tree(popularity_coded ~ duration_ms+explicit+danceability+energy+key+loudness+mode+speechiness+acousticness+instrumentalness+liveness+valence+tempo+time_signature, data = train)
summary(tree.class)
plot(tree.class)
text(tree.class, cex=2, col="purple")
tree.class <- tree(popularity_coded ~ duration_ms+explicit+danceability+energy+key+loudness+mode+speechiness+acousticness+instrumentalness+liveness+valence+tempo+time_signature, data = train)
summary(tree.class)
plot(tree.class)
text(tree.class, cex=1.5, col="purple")
cv.class = cv.tree(tree.class)
plot(cv.class$size, cv.class$dev, type='b', xlim=c(0,12))
text(cv.rings$size+0.4, cv.class$dev, round(cv.class$dev), cex=0.6)
cv.class = cv.tree(tree.class)
plot(cv.class$size, cv.class$dev, type='b')
text(cv.class$size+0.4, cv.class$dev, round(cv.class$dev), cex=0.6)
cv.class = cv.tree(tree.class)
plot(cv.class$size, cv.class$dev, type='b')
text(cv.class$size+0.1, cv.class$dev, round(cv.class$dev), cex=1)
cv.class = cv.tree(tree.class)
plot(cv.class$size, cv.class$dev, type='b')
cv.class = cv.tree(tree.class)
plot(cv.class$size, cv.class$dev, type='b')
text(cex=1.5, col="purple")
cv.class = cv.tree(tree.class)
plot(cv.class$size, cv.class$dev, type='b')
text(cex=1.5)
cv.class = cv.tree(tree.class)
plot(cv.class$size, cv.class$dev, type='b', cex.main=1.5, cex.lab=1.5, cex.axis=1.5)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
for (i in 1:10){
idx <- strat_folds[[i]]
fold <- df[idx,]
print(table(fold$Type))
}
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
for (i in 1:10){
idx <- strat_folds[[i]]
fold <- df[idx,]
print(table(fold$popularity_coded))
}
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
for (i in 1:10){
idx <- strat_folds[[i]]
fold <- df[idx,]
}
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
for (i in 1:10){
idx <- strat_folds[i]
fold <- df[idx,]
}
set.seed(10)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
for (i in 1:10){
idx <- strat_folds[[i]]
fold <- df[idx,]
print(table(fold$popularity_coded))
}
View(strat_folds)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(survey)
library(sampling)
library(mlbench)
library(regclass)
library(MASS)
library(klaR)
library(caret)
library(AppliedPredictiveModeling)
library(ISLR)
library(tree)
set.seed(10)
strat_folds <- createFolds(factor(df$Type), k=10)
set.seed(10)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
strat_folds[i]
set.seed(10)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
for (i in 1:10){
idx <- strat_folds[i]
fold <- df[idx,]
print(table(fold$popularity_coded))
}
set.seed(10)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
for (i in 1:10){
idx <- strat_folds[[i]]
fold <- df[idx,]
print(table(fold$popularity_coded))
}
set.seed(10)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
strat_fold[[1]]
set.seed(10)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
strat_folds[[1]]
set.seed(10)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
class(strat_folds[[1]])
set.seed(10)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
class(as.list(strat_folds[[1]]))
set.seed(10)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
c = class(as.list(strat_folds[[1]]))
c
set.seed(10)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
c = as.list(strat_folds[[1]])
c
set.seed(10)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
c = as.list(strat_folds[1])
c
set.seed(10)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
for (i in 1:10){
idx <- as.list(strat_folds[i])
fold <- df[idx,]
print(table(fold$popularity_coded))
}
set.seed(10)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
for (i in 1:10){
idx <- as.list(strat_folds[[i]])
fold <- df[idx,]
print(table(fold$popularity_coded))
}
mis_tree <- function(idx){
Train <- df[-idx,]
Test <- df[idx,]
tree.class <- tree(popularity_coded ~ duration_ms+explicit+danceability+energy+key+loudness+mode+speechiness+acousticness+instrumentalness+liveness+valence+tempo+time_signature, data = Train)
tree_hat <- predict(tree.ckass, Test, type = "class")
tab <- table(tree_hat, Test$popularity_coded)
print(tab)
misclass = 1 - sum(diag(tab)) / sum(tab)
print(misclass)
return(misclass)
}
misclass_tree = lapply(strat_folds, mis_tree)
mis_tree <- function(idx){
Train <- df[-idx,]
Test <- df[idx,]
tree.class <- tree(popularity_coded ~ duration_ms+explicit+danceability+energy+key+loudness+mode+speechiness+acousticness+instrumentalness+liveness+valence+tempo+time_signature, data = Train)
tree_hat <- predict(tree.ckass, Test, type = "class")
tab <- table(tree_hat, Test$popularity_coded)
print(tab)
misclass = 1 - sum(diag(tab)) / sum(tab)
print(misclass)
return(misclass)
}
misclass_tree = lapply(strat_folds, mis_tree)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(survey)
library(sampling)
library(mlbench)
library(regclass)
library(MASS)
library(klaR)
library(caret)
library(AppliedPredictiveModeling)
library(ISLR)
library(tree)
library(AppliedPredictiveModeling)
data(abalone)
df <- abalone
columns = colnames(df)
columns
dimensions <- dim(df)
dimensions
set.seed(10)
idx = sample(1:dimensions[1], 3/4*dimensions[1])
train = df[idx,]
test = df[-idx,]
tree.rings <- tree(Rings~., train)
summary(tree.rings)
plot(tree.rings)
text(tree.rings, cex=0.5, col="blue")
rings_hat <- predict(tree.rings, test)
plot(rings_hat, test$Rings)
abline(0,1)
#one method
sqrt(mean((rings_hat-test$Rings)^2))
#second method
RMSE(rings_hat, test$Rings)
set.seed(10)
cv.rings = cv.tree(tree.rings)
plot(cv.rings$size, cv.rings$dev, type='b', xlim=c(0,12))
text(cv.rings$size+0.4, cv.rings$dev, round(cv.rings$dev), cex=0.6)
prune.rings <- prune.tree(tree.rings,best=9)
plot(prune.rings)
text(prune.rings, cex=0.5, col="blue")
rings_hat <- predict(prune.rings, test)
plot(rings_hat, test$Rings)
abline(0,1)
RMSE(rings_hat, test$Rings)
set.seed(10)
folds<-createFolds(abalone$Rings, k=10)
rmse_tree <- function(idx){
Train <- df[-idx,]
Test <- df[idx,]
tree.fit <- tree(Rings~., Train)
tree_hat <- predict(tree.fit, Test)
rmse_tree = RMSE(tree_hat, Test$Rings)
return(rmse_tree)
}
rmse_trees = lapply(folds, rmse_tree)
rmse_trees
mean(as.numeric(rmse_trees))
rmse_lm <- function(idx){
Train <- df[-idx,]
Test <- df[idx,]
lm.fit <- lm(Rings~., data=Train)
lm_hat <- predict(lm.fit, Test)
rmse_lm = RMSE(lm_hat, Test$Rings)
return(rmse_lm)
}
rmse_lms = lapply(folds, rmse_lm)
rmse_lms
mean(as.numeric(rmse_lms))
set.seed(10)
idx = sample(1:dimensions[1], 3/4*dimensions[1])
train = df[idx,]
test = df[-idx,]
tree.type <- tree(factor(Type)~., train)
summary(tree.type)
plot(tree.type)
text(tree.type, cex=0.5, col="blue")
unique(df$Type)
set.seed(10)
tree.pred <- predict(tree.type, test, type = "class")
tab <- table(tree.pred, test$Type)
tab
mis = 1 - sum(diag(tab)) / sum(tab)
mis
set.seed(10)
cv.type <- cv.tree(tree.type, FUN=prune.misclass, K=10)
plot(cv.type$size, cv.type$dev, type="b")
prune.type = prune.tree(tree.type, best=3)
plot(prune.type)
text(prune.type, cex=0.5, col="blue")
prune.pred <- predict(prune.type, test, type = "class")
tab <- table(prune.pred, test$Type)
tab
mis = 1 - sum(diag(tab)) / sum(tab)
mis
for (i in 1:10){
idx <- folds[[i]]
fold <- df[idx,]
print(table(fold$Type))
}
set.seed(10)
strat_folds <- createFolds(factor(df$Type), k=10)
for (i in 1:10){
idx <- strat_folds[[i]]
fold <- df[idx,]
print(table(fold$Type))
}
set.seed(10)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
for (i in 1:10){
idx <- strat_folds[[i]]
fold <- df[idx,]
print(table(fold$popularity_coded))
}
set.seed(10)
strat_folds <- createFolds(factor(popular_df2$popularity_coded), k=10)
for (i in 1:10){
idx <- strat_folds[[i]]
fold <- popular_df2[idx,]
print(table(fold$popularity_coded))
}
mis_tree <- function(idx){
Train <- df[-idx,]
Test <- df[idx,]
tree.class <- tree(popularity_coded ~ duration_ms+explicit+danceability+energy+key+loudness+mode+speechiness+acousticness+instrumentalness+liveness+valence+tempo+time_signature, data = Train)
tree_hat <- predict(tree.ckass, Test, type = "class")
tab <- table(tree_hat, Test$popularity_coded)
print(tab)
misclass = 1 - sum(diag(tab)) / sum(tab)
print(misclass)
return(misclass)
}
misclass_tree = lapply(strat_folds, mis_tree)
mis_tree <- function(idx){
Train <- popular_df2[-idx,]
Test <- popular_df2[idx,]
tree.class <- tree(popularity_coded ~ duration_ms+explicit+danceability+energy+key+loudness+mode+speechiness+acousticness+instrumentalness+liveness+valence+tempo+time_signature, data = Train)
tree_hat <- predict(tree.ckass, Test, type = "class")
tab <- table(tree_hat, Test$popularity_coded)
print(tab)
misclass = 1 - sum(diag(tab)) / sum(tab)
print(misclass)
return(misclass)
}
misclass_tree = lapply(strat_folds, mis_tree)
mis_tree <- function(idx){
Train <- popular_df2[-idx,]
Test <- popular_df2[idx,]
tree.class <- tree(popularity_coded ~ duration_ms+explicit+danceability+energy+key+loudness+mode+speechiness+acousticness+instrumentalness+liveness+valence+tempo+time_signature, data = Train)
tree_hat <- predict(tree.class, Test, type = "class")
tab <- table(tree_hat, Test$popularity_coded)
print(tab)
misclass = 1 - sum(diag(tab)) / sum(tab)
print(misclass)
return(misclass)
}
misclass_tree = lapply(strat_folds, mis_tree)
"The mean misclassification:"
mean(as.numeric(misclass_tree))
#clean the artists to those with only one genre and of the primary genre types
artist_genres <- artists_df %>%
filter(genres != "[]") %>%
mutate(genres = toupper(genres),
rock = grepl("ROCK|METAL", genres, fixed=FALSE),
blues = grepl("BLUES", genres, fixed=FALSE),
pop = grepl("POP", genres, fixed=FALSE),
country = grepl("COUNTRY", genres, fixed=FALSE),
rap = grepl("RAP|HIP HOP", genres, fixed=FALSE),
jazz = grepl("JAZZ", genres, fixed=FALSE),
classical = grepl("CLASSICAL", genres, fixed=FALSE),
soul = grepl("SOUL", genres, fixed=FALSE),
reggae = grepl("REGGAE", genres, fixed=FALSE),
electronic = grepl("ELECTRONIC|HOUSE|DNB|EDM", genres, fixed=FALSE),
disco = grepl("DISCO", genres, fixed=FALSE),
num_genres = rock + blues + pop + country + rap + jazz + classical + soul + reggae +electronic + disco) %>%
filter(num_genres == 1) %>%
mutate(genre = case_when(rock == 1 ~ "rock",
blues == 1 ~ "blues",
pop == 1 ~ "pop",
country == 1 ~ "country",
rap == 1 ~ "rap",
jazz == 1 ~ "jazz",
classical == 1 ~ "classical",
soul == 1 ~ "soul",
reggae == 1 ~ "reggae",
electronic == 1 ~ "electronic",
disco == 1 ~ "disco")) %>%
dplyr::select(id, genre, name, popularity)
#clean the track artist lists
rep_str = c("\\[" = "", "\\]"="", "'"="")
track_artists <- tracks_df
track_artists$id_artists <- str_replace_all(track_artists$id_artists, rep_str)
track_artists$id_artists <- as.list(track_artists$id_artists)
#inner join so only the artists with single genre remain alongsige the track data
genre_tracks <- merge(x=artist_genres, y=track_artists, by.x="id", by.y="id_artists")
colnames(genre_tracks)
colnames(genre_tracks) <- c("artist_id", "genre", "artist_name", "artist_popularity", "song_id", "song_name", "song_popularity", "duration_ms", "explicit", "artists", "release_date", "danceability", "energy", "key", "loudness", "mode", "speechiness", "acousticness", "instrumentalness", "liveness", "valence", "tempo", "time_signature")
#count the strata to understand what should be used to test/train
n = round(dim(genre_tracks)[1]*0.75)
N = dim(genre_tracks)[1]
order <- unique(genre_tracks$genre)
order
strata <- genre_tracks %>%
count(genre) %>%
rename(Nh = n) %>%
mutate(nh = round(Nh*n/N)) %>%
slice(match(order, genre))
#inner join so only the artists with single genre remain alongsige the track data
genre_tracks <- merge(x=artist_genres, y=track_artists, by.x="id", by.y="id_artists")
colnames(genre_tracks)
colnames(genre_tracks) <- c("artist_id", "genre", "artist_name", "artist_popularity", "song_id", "song_name", "song_popularity", "duration_ms", "explicit", "artists", "release_date", "danceability", "energy", "key", "loudness", "mode", "speechiness", "acousticness", "instrumentalness", "liveness", "valence", "tempo", "time_signature", "year", "decade")
#count the strata to understand what should be used to test/train
n = round(dim(genre_tracks)[1]*0.75)
N = dim(genre_tracks)[1]
order <- unique(genre_tracks$genre)
order
strata <- genre_tracks %>%
count(genre) %>%
rename(Nh = n) %>%
mutate(nh = round(Nh*n/N)) %>%
slice(match(order, genre))
strata
strata_sizes <- strata$nh
#perform the stratified sample
idx_strat <- sampling:::strata(genre_tracks, stratanames=c("genre"), size=strata_sizes, method="srswor")
train_genre <- genre_tracks[idx_strat$ID_unit,]
test_genre <- genre_tracks[-idx_strat$ID_unit,]
#perform the stratified sample
idx_strat <- sampling:::strata(genre_tracks, stratanames=c("genre"), size=strata_sizes, method="srswor")
train_genre <- genre_tracks[idx_strat$ID_unit,]
test_genre <- genre_tracks[-idx_strat$ID_unit,]
#build tree genre
tree.genre <- tree(factor(genre)~duration_ms+factor(explicit)+danceability+energy+factor(key)+loudness+factor(mode)+speechiness+acousticness+instrumentalness+liveness+valence+tempo, train_genre)
summary(tree.genre)
plot(tree.genre)
text(tree.genre, cex=1.5, col="purple")
set.seed(10)
strat_folds <- createFolds(factor(genre_tracks$genre), k=10)
for (i in 1:10){
idx <- strat_folds[[i]]
fold <- genre_tracks[idx,]
print(table(fold$genre))
}
mis_tree <- function(idx){
Train <- genre_tracks[-idx,]
Test <- genre_tracks[idx,]
tree.genre <- tree(factor(genre)~duration_ms+factor(explicit)+danceability+energy+factor(key)+loudness+factor(mode)+speechiness+acousticness+instrumentalness+liveness+valence+tempo, Train)
tree_hat <- predict(tree.genre, Test, type = "class")
tab <- table(tree_hat, Test$genre)
print(tab)
misclass = 1 - sum(diag(tab)) / sum(tab)
print(misclass)
return(misclass)
}
misclass_tree = lapply(strat_folds, mis_tree)
"The mean misclassification:"
mean(as.numeric(misclass_tree))
#count the strata to understand what should be used to test/train
n = round(dim(genre_tracks)[1]*0.75)
N = dim(genre_tracks)[1]
order <- unique(genre_tracks$genre)
order
strata <- genre_tracks %>%
count(genre) %>%
rename(count = n) %>%
slice(match(order, genre))
strata
strata_sizes <- strata$nh
